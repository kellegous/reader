package miniflux

import (
	"context"
	"crypto/rand"
	"database/sql"
	"encoding/base64"
	"net/http"
	"net/http/cookiejar"
	"os"
	"os/exec"
	"time"

	"github.com/jackc/pgx/v5"
	"github.com/kellegous/poop"
	"miniflux.app/v2/client"
)

type Server struct {
	proc *os.Process
	opts Options
	keys map[string]*client.APIKey
}

func (s *Server) Stop() error {
	return s.proc.Kill()
}

func (s *Server) Client(opts ...client.Option) *client.Client {
	if a := s.opts.admin; a != nil {
		opts = append(opts, client.WithCredentials(a.username, a.password))
	}

	return client.NewClientWithOptions(
		s.opts.internalURL,
		opts...)
}

func (s *Server) SQLConn(ctx context.Context) (*pgx.Conn, error) {
	c, err := pgx.Connect(ctx, s.opts.databaseURL)
	if err != nil {
		return nil, poop.Chain(err)
	}
	return c, nil
}

func (s *Server) APIKeyFor(username string) *client.APIKey {
	return s.keys[username]
}

func (s *Server) BaseURL() string {
	return s.opts.internalURL
}

func (s *Server) provisionAuthProxyUser(
	ctx context.Context,
	user string,
) error {
	jar, err := cookiejar.New(&cookiejar.Options{})
	if err != nil {
		return poop.Chain(err)
	}

	// this check has to have a cookie jar so that miniflux can see
	// its own session cookie, otherwise it will redirect indefinitely
	client := &http.Client{
		Jar: jar,
	}

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, s.BaseURL()+"/", nil)
	if err != nil {
		return poop.Chain(err)
	}

	req.Header.Set(s.opts.authProxy.header, user)

	res, err := client.Do(req)
	if err != nil {
		return poop.Chain(err)
	}
	defer res.Body.Close()

	if res.StatusCode != http.StatusOK {
		return poop.Newf("status %d for auth proxy user: %s", res.StatusCode, user)
	}

	return nil
}

func waitForLiveness(
	ctx context.Context,
	s *Server,
	timeout time.Duration,
) error {
	ctx, cancel := context.WithTimeout(ctx, timeout)
	defer cancel()

	doCheck := func() error {
		req, err := http.NewRequestWithContext(ctx, http.MethodGet, s.BaseURL()+"/liveness", nil)
		if err != nil {
			return poop.Chain(err)
		}

		res, err := http.DefaultClient.Do(req)
		if err != nil {
			return poop.Chain(err)
		}
		defer res.Body.Close()

		if res.StatusCode != http.StatusOK {
			return poop.Newf("status %d for liveness check", res.StatusCode)
		}

		return nil
	}

	for {
		if err := doCheck(); err == nil {
			return nil
		}

		select {
		case <-ctx.Done():
			return ctx.Err()
		case <-time.After(200 * time.Millisecond):
		}
	}
}

func ensureAPIKeyFor(
	ctx context.Context,
	s *Server,
	username string,
) (*client.APIKey, error) {
	user, err := s.Client().UserByUsernameContext(ctx, username)
	if err != nil {
		return nil, poop.Chain(err)
	}

	db, err := s.SQLConn(ctx)
	if err != nil {
		return nil, poop.Chain(err)
	}
	defer db.Close(ctx)

	var key client.APIKey
	if err := db.QueryRow(
		ctx,
		`SELECT id, user_id, token, description, last_used_at, created_at FROM api_keys WHERE user_id = $1 LIMIT 1`,
		user.ID,
	).Scan(
		&key.ID,
		&key.UserID,
		&key.Token,
		&key.Description,
		&key.LastUsedAt,
		&key.CreatedAt,
	); err == nil {
		return &key, nil
	} else if err != sql.ErrNoRows {
		return nil, poop.Chain(err)
	}

	var buf [32]byte
	_, err = rand.Read(buf[:])
	if err != nil {
		return nil, poop.Chain(err)
	}

	if err := db.QueryRow(
		ctx,
		`INSERT INTO api_keys (user_id, token, description)
		VALUES ($1, $2, $3)
		RETURNING id, user_id, token, description, last_used_at, created_at`,
		user.ID,
		base64.StdEncoding.EncodeToString(buf[:]),
		"generated by reader",
	).Scan(
		&key.ID,
		&key.UserID,
		&key.Token,
		&key.Description,
		&key.LastUsedAt,
		&key.CreatedAt,
	); err != nil {
		return nil, poop.Chain(err)
	}

	return &key, nil
}

func Start(ctx context.Context, opts ...Option) (*Server, error) {
	s := &Server{}
	for _, opt := range opts {
		if err := opt(&s.opts); err != nil {
			return nil, err
		}
	}

	c := exec.CommandContext(ctx, "miniflux")
	c.Env = s.opts.env()
	c.Stdout = os.Stdout
	c.Stderr = os.Stderr
	if err := c.Start(); err != nil {
		return nil, err
	}

	s.proc = c.Process

	if err := waitForLiveness(ctx, s, 10*time.Second); err != nil {
		return nil, poop.Chain(err)
	}

	s.keys = make(map[string]*client.APIKey)
	if p := s.opts.authProxy; p != nil {
		for _, user := range p.users {
			if err := s.provisionAuthProxyUser(ctx, user); err != nil {
				return nil, poop.Chain(err)
			}

			key, err := ensureAPIKeyFor(ctx, s, user)
			if err != nil {
				return nil, poop.Chain(err)
			}
			s.keys[user] = key
		}
	}

	return s, nil
}
